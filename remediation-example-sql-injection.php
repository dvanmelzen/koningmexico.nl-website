<?php
/**
 * REMEDIATION EXAMPLE: SQL Injection Fix
 * Generated by: Claude Code
 * Date: 2025-12-28
 * DANIEL ref: JN042
 * Nessus Finding: SQL Injection in login.php
 */

// ❌ BEFORE (Vulnerable to SQL Injection)
class LoginControllerVulnerable {
    private $db;

    public function login($username, $password) {
        // VULNERABLE: Direct string concatenation
        $query = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
        $result = $this->db->query($query);

        // Attacker can use: ' OR '1'='1
        return $result->num_rows > 0;
    }
}

// ✅ AFTER (Fixed with Prepared Statements)
class LoginControllerSecure {
    private $db;

    public function login($username, $password) {
        // SECURE: Use prepared statements with parameterized queries
        $stmt = $this->db->prepare("SELECT * FROM users WHERE username = ? AND password_hash = ?");

        if (!$stmt) {
            error_log("Database prepare failed: " . $this->db->error);
            return false;
        }

        // Hash password (assuming bcrypt/Argon2 used during registration)
        $password_hash = password_hash($password, PASSWORD_ARGON2ID);

        // Bind parameters (prevents SQL injection)
        $stmt->bind_param("ss", $username, $password_hash);

        // Execute query
        $stmt->execute();

        // Get result
        $result = $stmt->get_result();
        $user = $result->fetch_assoc();

        $stmt->close();

        // Verify password using secure comparison
        if ($user && password_verify($password, $user['password_hash'])) {
            // Additional security: Log successful login
            $this->logSecurityEvent('login_success', $username);

            // Regenerate session ID (prevent session fixation)
            session_regenerate_id(true);

            return true;
        }

        // Log failed attempt (rate limiting, brute force detection)
        $this->logSecurityEvent('login_failed', $username);

        return false;
    }

    private function logSecurityEvent($event_type, $username) {
        // DANIEL integration: Log to journal
        $timestamp = date('Y-m-d H:i');
        $log_entry = "[$timestamp] Security Event: $event_type for user: $username";
        error_log($log_entry);

        // Could also write to DANIEL:
        // exec("jn -observation 'custom-connect: $log_entry'");
    }
}

/**
 * ADDITIONAL SECURITY IMPROVEMENTS:
 *
 * 1. Rate Limiting:
 *    - Max 5 failed attempts per IP per 15 minutes
 *    - Temporary account lockout after 10 failed attempts
 *
 * 2. Input Validation:
 *    - Username: alphanumeric + underscore only (regex: ^[a-zA-Z0-9_]{3,20}$)
 *    - Password: min 12 chars, complexity requirements
 *
 * 3. Security Headers (add to .htaccess or Apache config):
 *    Header set Content-Security-Policy "default-src 'self'"
 *    Header set X-Frame-Options "DENY"
 *    Header set X-Content-Type-Options "nosniff"
 *    Header set Strict-Transport-Security "max-age=31536000; includeSubDomains"
 *
 * 4. Database User Permissions:
 *    - Web app should use MySQL user with SELECT/INSERT/UPDATE only
 *    - No DROP, CREATE, ALTER permissions
 *    - No FILE, GRANT permissions
 *
 * 5. Logging & Monitoring:
 *    - All authentication events → SIEM
 *    - Failed login patterns → Alert
 *    - DANIEL journal for security decisions
 */

// Unit test (PHPUnit)
class LoginControllerSecureTest extends \PHPUnit\Framework\TestCase {
    public function testSQLInjectionAttemptFails() {
        $controller = new LoginControllerSecure();

        // Simulate SQL injection attempt
        $malicious_username = "admin' OR '1'='1";
        $result = $controller->login($malicious_username, "password");

        // Should fail (returns false)
        $this->assertFalse($result, "SQL injection attempt should be blocked");
    }

    public function testValidLoginSucceeds() {
        $controller = new LoginControllerSecure();

        // Valid credentials
        $result = $controller->login("testuser", "ValidPassword123!");

        // Should succeed (assuming user exists)
        $this->assertTrue($result, "Valid login should succeed");
    }
}

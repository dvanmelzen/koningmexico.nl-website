// Multiplayer Mexico Backend Server
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const cors = require('cors');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

// Configuration
const PORT = process.env.PORT || 8080;
const JWT_SECRET = process.env.JWT_SECRET || 'mexico-secret-key-change-in-production';

// Initialize Express & Socket.io
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: '*',
        methods: ['GET', 'POST']
    }
});

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('../')); // Serve frontend files

// ============================================
// IN-MEMORY DATABASE (Replace with real DB in production)
// ============================================

const users = new Map(); // userId -> user object
const usersByUsername = new Map(); // username -> userId
const games = new Map(); // gameId -> game object
const matchmakingQueue = []; // Array of { userId, eloRating, socketId }
const activeSockets = new Map(); // socketId -> userId

// ============================================
// HELPER FUNCTIONS
// ============================================

// Generate JWT token
function generateToken(user) {
    return jwt.sign(
        { id: user.id, username: user.username },
        JWT_SECRET,
        { expiresIn: '7d' }
    );
}

// Verify JWT token
function verifyToken(token) {
    try {
        return jwt.verify(token, JWT_SECRET);
    } catch (error) {
        return null;
    }
}

// Calculate Elo rating change
function calculateEloChange(winnerElo, loserElo, K = 32) {
    const expectedWin = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
    const winnerChange = Math.round(K * (1 - expectedWin));
    const loserChange = Math.round(K * (0 - (1 - expectedWin)));
    return { winnerChange, loserChange };
}

// Mexico throw value calculation
function calculateThrowValue(dice1, dice2) {
    // Mexico (2-1 or 1-2) = highest value
    if ((dice1 === 2 && dice2 === 1) || (dice1 === 1 && dice2 === 2)) {
        return { value: 1000, name: 'Mexico', isMexico: true };
    }

    // Pairs (e.g., 6-6, 5-5)
    if (dice1 === dice2) {
        return { value: 100 + dice1, name: `Dubbel ${dice1}`, isMexico: false };
    }

    // Regular throws (higher die first)
    const high = Math.max(dice1, dice2);
    const low = Math.min(dice1, dice2);
    return { value: high * 10 + low, name: `${high}-${low}`, isMexico: false };
}

// Determine round winner
function determineRoundWinner(throw1, throw2) {
    if (throw1.value > throw2.value) return 'player1';
    if (throw2.value > throw1.value) return 'player2';
    return 'tie'; // Vastgooier
}

// Calculate penalty (lives lost)
function calculatePenalty(winnerThrow, loserThrow) {
    // Mexico = 2 lives
    if (winnerThrow.isMexico) return 2;

    // Double 1 (snake eyes) = 1 life (special case)
    if (loserThrow.dice1 === 1 && loserThrow.dice2 === 1) return 1;

    // Default = 1 life
    return 1;
}

// ============================================
// REST API ENDPOINTS
// ============================================

// Health check
app.get('/api/health', (req, res) => {
    res.json({ status: 'OK', players: users.size, games: games.size });
});

// Register
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, password } = req.body;

        // Validation
        if (!username || !email || !password) {
            return res.status(400).json({ message: 'Alle velden zijn verplicht' });
        }
        if (username.length < 3 || username.length > 50) {
            return res.status(400).json({ message: 'Gebruikersnaam moet 3-50 karakters zijn' });
        }
        if (password.length < 6) {
            return res.status(400).json({ message: 'Wachtwoord moet minimaal 6 karakters zijn' });
        }

        // Check if username exists
        if (usersByUsername.has(username.toLowerCase())) {
            return res.status(400).json({ message: 'Gebruikersnaam bestaat al' });
        }

        // Hash password
        const hashedPassword = await bcrypt.hash(password, 10);

        // Create user
        const user = {
            id: uuidv4(),
            username,
            email,
            password: hashedPassword,
            eloRating: 1200,
            avatarEmoji: 'ðŸ‘¤',
            stats: {
                wins: 0,
                losses: 0,
                gamesPlayed: 0
            },
            createdAt: new Date()
        };

        users.set(user.id, user);
        usersByUsername.set(username.toLowerCase(), user.id);

        // Generate token
        const accessToken = generateToken(user);

        // Return user (without password)
        const { password: _, ...userResponse } = user;
        res.status(201).json({
            user: userResponse,
            accessToken
        });

    } catch (error) {
        console.error('Register error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Login
app.post('/api/auth/login', async (req, res) => {
    try {
        const { username, password } = req.body;

        // Validation
        if (!username || !password) {
            return res.status(400).json({ message: 'Gebruikersnaam en wachtwoord verplicht' });
        }

        // Find user
        const userId = usersByUsername.get(username.toLowerCase());
        if (!userId) {
            return res.status(401).json({ message: 'Ongeldige inloggegevens' });
        }

        const user = users.get(userId);

        // Check password
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            return res.status(401).json({ message: 'Ongeldige inloggegevens' });
        }

        // Generate token
        const accessToken = generateToken(user);

        // Return user (without password)
        const { password: _, ...userResponse } = user;
        res.status(200).json({
            user: userResponse,
            accessToken
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ message: 'Server error' });
    }
});

// Leaderboard
app.get('/api/leaderboard', (req, res) => {
    const players = Array.from(users.values())
        .map(({ password, ...user }) => user)
        .sort((a, b) => b.eloRating - a.eloRating)
        .slice(0, 100);

    res.json({ players });
});

// ============================================
// SOCKET.IO CONNECTION & AUTHENTICATION
// ============================================

io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    if (!token) {
        return next(new Error('Authentication error'));
    }

    const decoded = verifyToken(token);
    if (!decoded) {
        return next(new Error('Invalid token'));
    }

    socket.userId = decoded.id;
    next();
});

io.on('connection', (socket) => {
    const userId = socket.userId;
    const user = users.get(userId);

    if (!user) {
        socket.disconnect();
        return;
    }

    console.log(`âœ… User connected: ${user.username} (${socket.id})`);
    activeSockets.set(socket.id, userId);

    socket.emit('authenticated', { username: user.username });

    // ============================================
    // MATCHMAKING
    // ============================================

    socket.on('join_queue', ({ gameMode }) => {
        console.log(`ðŸ” ${user.username} joined matchmaking queue`);

        // Remove from queue if already there
        const existingIndex = matchmakingQueue.findIndex(p => p.userId === userId);
        if (existingIndex !== -1) {
            matchmakingQueue.splice(existingIndex, 1);
        }

        // Add to queue
        matchmakingQueue.push({
            userId,
            username: user.username,
            eloRating: user.eloRating,
            socketId: socket.id,
            gameMode
        });

        socket.emit('queue_joined', { queueSize: matchmakingQueue.length });

        // Try to find a match
        tryMatchmaking();
    });

    socket.on('leave_queue', () => {
        const index = matchmakingQueue.findIndex(p => p.userId === userId);
        if (index !== -1) {
            matchmakingQueue.splice(index, 1);
            console.log(`âŒ ${user.username} left matchmaking queue`);
        }
    });

    // ============================================
    // GAME EVENTS
    // ============================================

    socket.on('throw_dice', ({ gameId, isBlind }) => {
        const game = games.get(gameId);
        if (!game || game.currentTurn !== userId) {
            return socket.emit('error', { message: 'Not your turn' });
        }

        handleThrow(game, userId, isBlind);
    });

    socket.on('keep_throw', ({ gameId }) => {
        const game = games.get(gameId);
        if (!game || game.currentTurn !== userId) {
            return socket.emit('error', { message: 'Not your turn' });
        }

        handleKeep(game, userId);
    });

    socket.on('give_up', ({ gameId }) => {
        const game = games.get(gameId);
        if (!game || game.currentTurn !== userId) {
            return socket.emit('error', { message: 'Not your turn' });
        }

        handleGiveUp(game, userId);
    });

    socket.on('return_to_lobby', ({ gameId }) => {
        const game = games.get(gameId);
        if (game) {
            games.delete(gameId);
        }
    });

    // ============================================
    // DISCONNECT
    // ============================================

    socket.on('disconnect', () => {
        console.log(`âŒ User disconnected: ${user.username}`);
        activeSockets.delete(socket.id);

        // Remove from queue
        const queueIndex = matchmakingQueue.findIndex(p => p.userId === userId);
        if (queueIndex !== -1) {
            matchmakingQueue.splice(queueIndex, 1);
        }

        // Handle active games (forfeit)
        for (const [gameId, game] of games.entries()) {
            if (game.player1Id === userId || game.player2Id === userId) {
                const winnerId = game.player1Id === userId ? game.player2Id : game.player1Id;
                endGame(game, winnerId, 'opponent_disconnected');
            }
        }
    });
});

// ============================================
// MATCHMAKING LOGIC
// ============================================

function tryMatchmaking() {
    if (matchmakingQueue.length < 2) return;

    // Sort by Elo for better matching
    matchmakingQueue.sort((a, b) => a.eloRating - b.eloRating);

    // Match first two players (simple for now, can improve with Elo range)
    const player1 = matchmakingQueue.shift();
    const player2 = matchmakingQueue.shift();

    createGame(player1, player2);
}

function createGame(player1Data, player2Data) {
    const gameId = uuidv4();

    const player1 = users.get(player1Data.userId);
    const player2 = users.get(player2Data.userId);

    const game = {
        gameId,
        player1Id: player1.id,
        player2Id: player2.id,
        player1SocketId: player1Data.socketId,
        player2SocketId: player2Data.socketId,
        player1Lives: 6,
        player2Lives: 6,
        roundNumber: 1,
        voorgooier: player1.id, // Player 1 starts as voorgooier
        currentTurn: player1.id,
        isFirstRound: true,
        maxThrows: 3,
        player1Throw: null,
        player2Throw: null,
        player1ThrowCount: 0,
        player2ThrowCount: 0,
        voorgooierPattern: [], // Track blind/open pattern
        status: 'active',
        startedAt: new Date()
    };

    games.set(gameId, game);

    console.log(`ðŸŽ® Game created: ${player1.username} vs ${player2.username}`);

    // Notify both players of match found
    io.to(player1Data.socketId).emit('match_found', {
        opponent: {
            username: player2.username,
            eloRating: player2.eloRating,
            avatarEmoji: player2.avatarEmoji
        }
    });

    io.to(player2Data.socketId).emit('match_found', {
        opponent: {
            username: player1.username,
            eloRating: player1.eloRating,
            avatarEmoji: player1.avatarEmoji
        }
    });

    // Start game after short delay
    setTimeout(() => startGame(game), 2000);
}

function startGame(game) {
    const player1 = users.get(game.player1Id);
    const player2 = users.get(game.player2Id);

    const gameStartData = {
        gameId: game.gameId,
        players: [
            {
                id: player1.id,
                username: player1.username,
                eloRating: player1.eloRating,
                lives: game.player1Lives
            },
            {
                id: player2.id,
                username: player2.username,
                eloRating: player2.eloRating,
                lives: game.player2Lives
            }
        ],
        roundNumber: game.roundNumber,
        voorgooier: game.voorgooier,
        currentTurn: game.currentTurn,
        isFirstRound: game.isFirstRound,
        maxThrows: game.maxThrows
    };

    io.to(game.player1SocketId).emit('game_start', gameStartData);
    io.to(game.player2SocketId).emit('game_start', gameStartData);

    console.log(`â–¶ï¸  Game started: ${player1.username} vs ${player2.username}`);
}

// ============================================
// GAME LOGIC - MEXICO RULES
// ============================================

function handleThrow(game, userId, isBlind) {
    const isPlayer1 = userId === game.player1Id;
    const throwCount = isPlayer1 ? ++game.player1ThrowCount : ++game.player2ThrowCount;

    console.log(`ðŸŽ² ${isPlayer1 ? 'Player1' : 'Player2'} throws ${isBlind ? 'BLIND' : 'OPEN'} (throw ${throwCount}/${game.maxThrows})`);

    // Roll dice
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const throwResult = calculateThrowValue(dice1, dice2);

    // Store throw
    const throwData = {
        dice1,
        dice2,
        ...throwResult,
        isBlind,
        throwCount
    };

    if (isPlayer1) {
        game.player1Throw = throwData;
        // Track voorgooier pattern
        if (game.voorgooier === game.player1Id) {
            game.voorgooierPattern.push(isBlind);
        }
    } else {
        game.player2Throw = throwData;
        // Track voorgooier pattern
        if (game.voorgooier === game.player2Id) {
            game.voorgooierPattern.push(isBlind);
        }
    }

    // Send result to player who threw
    const playerSocketId = isPlayer1 ? game.player1SocketId : game.player2SocketId;
    io.to(playerSocketId).emit('throw_result', {
        ...throwData,
        maxThrows: game.maxThrows
    });

    // Notify opponent (without revealing dice if blind)
    const opponentSocketId = isPlayer1 ? game.player2SocketId : game.player1SocketId;
    io.to(opponentSocketId).emit('opponent_throw', {
        ...throwData,
        dice1: isBlind ? null : dice1,
        dice2: isBlind ? null : dice2
    });

    // RULE: First blind throw = auto-keep (no re-throw allowed in first round)
    if (game.isFirstRound && throwCount === 1) {
        console.log(`ðŸ”’ First round blind throw - auto keep`);
        handleKeep(game, userId);
    }
}

function handleKeep(game, userId) {
    const isPlayer1 = userId === game.player1Id;
    console.log(`âœ“ ${isPlayer1 ? 'Player1' : 'Player2'} keeps their throw`);

    // Check if both players have thrown
    if (game.player1Throw && game.player2Throw) {
        // Both players have thrown - compare results
        evaluateRound(game);
    } else {
        // Switch turn to opponent
        game.currentTurn = isPlayer1 ? game.player2Id : game.player1Id;

        io.to(game.player1SocketId).emit('turn_switched', {
            playerWhoKept: userId,
            currentTurn: game.currentTurn
        });
        io.to(game.player2SocketId).emit('turn_switched', {
            playerWhoKept: userId,
            currentTurn: game.currentTurn
        });

        console.log(`ðŸ”„ Turn switched to ${game.currentTurn === game.player1Id ? 'Player1' : 'Player2'}`);
    }
}

function handleGiveUp(game, userId) {
    const isPlayer1 = userId === game.player1Id;
    console.log(`âŒ ${isPlayer1 ? 'Player1' : 'Player2'} gives up`);

    // Give up = throw value 0
    const throwData = {
        dice1: 0,
        dice2: 0,
        value: 0,
        name: 'Pas',
        isMexico: false,
        isBlind: false,
        throwCount: 0
    };

    if (isPlayer1) {
        game.player1Throw = throwData;
    } else {
        game.player2Throw = throwData;
    }

    // Notify both players
    io.to(game.player1SocketId).emit('player_gave_up', { playerId: userId });
    io.to(game.player2SocketId).emit('player_gave_up', { playerId: userId });

    // If both players have decided (thrown or gave up), evaluate
    if (game.player1Throw && game.player2Throw) {
        evaluateRound(game);
    } else {
        // Switch turn
        game.currentTurn = isPlayer1 ? game.player2Id : game.player1Id;
        io.to(game.player1SocketId).emit('turn_switched', {
            playerWhoKept: userId,
            currentTurn: game.currentTurn
        });
        io.to(game.player2SocketId).emit('turn_switched', {
            playerWhoKept: userId,
            currentTurn: game.currentTurn
        });
    }
}

function evaluateRound(game) {
    console.log(`ðŸ“Š Evaluating round ${game.roundNumber}`);

    const throw1 = game.player1Throw;
    const throw2 = game.player2Throw;

    console.log(`  Player1: ${throw1.value} (${throw1.name})`);
    console.log(`  Player2: ${throw2.value} (${throw2.name})`);

    const result = determineRoundWinner(throw1, throw2);

    if (result === 'tie') {
        // VASTGOOIER - both threw same value
        console.log(`ðŸ¤ VASTGOOIER! Both threw ${throw1.value}`);

        io.to(game.player1SocketId).emit('vastgooier', { value: throw1.value });
        io.to(game.player2SocketId).emit('vastgooier', { value: throw1.value });

        // Reset for rethrow (1 throw only)
        game.player1Throw = null;
        game.player2Throw = null;
        game.player1ThrowCount = 0;
        game.player2ThrowCount = 0;
        game.maxThrows = 1;
        game.voorgooierPattern = [];

        setTimeout(() => {
            io.to(game.player1SocketId).emit('rethrow_needed', {
                currentTurn: game.currentTurn,
                maxThrows: game.maxThrows
            });
            io.to(game.player2SocketId).emit('rethrow_needed', {
                currentTurn: game.currentTurn,
                maxThrows: game.maxThrows
            });
        }, 2000);

        return;
    }

    // Determine winner and loser
    const winnerId = result === 'player1' ? game.player1Id : game.player2Id;
    const loserId = result === 'player1' ? game.player2Id : game.player1Id;
    const winnerThrow = result === 'player1' ? throw1 : throw2;
    const loserThrow = result === 'player1' ? throw2 : throw1;

    // Calculate penalty
    const penalty = calculatePenalty(winnerThrow, loserThrow);

    // Update lives
    if (result === 'player1') {
        game.player2Lives -= penalty;
    } else {
        game.player1Lives -= penalty;
    }

    console.log(`  Winner: ${result} (-${penalty} lives for loser)`);
    console.log(`  Lives: P1=${game.player1Lives}, P2=${game.player2Lives}`);

    // Send round result
    io.to(game.player1SocketId).emit('round_result', {
        winner: winnerId,
        loser: loserId,
        penalty,
        player1Id: game.player1Id,
        player2Id: game.player2Id,
        player1Throw: throw1,
        player2Throw: throw2,
        player1Lives: game.player1Lives,
        player2Lives: game.player2Lives
    });

    io.to(game.player2SocketId).emit('round_result', {
        winner: winnerId,
        loser: loserId,
        penalty,
        player1Id: game.player1Id,
        player2Id: game.player2Id,
        player1Throw: throw1,
        player2Throw: throw2,
        player1Lives: game.player1Lives,
        player2Lives: game.player2Lives
    });

    // Check for game over
    if (game.player1Lives <= 0 || game.player2Lives <= 0) {
        setTimeout(() => endGame(game, winnerId, 'lives_depleted'), 3000);
    } else {
        // Start new round
        setTimeout(() => startNewRound(game, loserId), 3000);
    }
}

function startNewRound(game, newVoorgooier) {
    game.roundNumber++;
    game.voorgooier = newVoorgooier; // Loser becomes voorgooier
    game.currentTurn = newVoorgooier;
    game.isFirstRound = false;
    game.maxThrows = 3;
    game.player1Throw = null;
    game.player2Throw = null;
    game.player1ThrowCount = 0;
    game.player2ThrowCount = 0;
    game.voorgooierPattern = [];

    console.log(`âš¡ New round ${game.roundNumber} - Voorgooier: ${newVoorgooier === game.player1Id ? 'Player1' : 'Player2'}`);

    const player1 = users.get(game.player1Id);
    const player2 = users.get(game.player2Id);

    const newRoundData = {
        gameId: game.gameId,
        roundNumber: game.roundNumber,
        voorgooier: game.voorgooier,
        currentTurn: game.currentTurn,
        isFirstRound: game.isFirstRound,
        maxThrows: game.maxThrows,
        players: [
            { id: player1.id, username: player1.username, eloRating: player1.eloRating, lives: game.player1Lives },
            { id: player2.id, username: player2.username, eloRating: player2.eloRating, lives: game.player2Lives }
        ]
    };

    io.to(game.player1SocketId).emit('new_round', newRoundData);
    io.to(game.player2SocketId).emit('new_round', newRoundData);
}

function endGame(game, winnerId, reason) {
    console.log(`ðŸ Game over - Winner: ${winnerId === game.player1Id ? 'Player1' : 'Player2'} (${reason})`);

    const loserId = winnerId === game.player1Id ? game.player2Id : game.player1Id;
    const winner = users.get(winnerId);
    const loser = users.get(loserId);

    // Update stats
    winner.stats.wins++;
    winner.stats.gamesPlayed++;
    loser.stats.losses++;
    loser.stats.gamesPlayed++;

    // Update Elo ratings
    const { winnerChange, loserChange } = calculateEloChange(winner.eloRating, loser.eloRating);
    winner.eloRating += winnerChange;
    loser.eloRating += loserChange;

    console.log(`  Elo changes: Winner +${winnerChange}, Loser ${loserChange}`);
    console.log(`  New Elos: ${winner.username}=${winner.eloRating}, ${loser.username}=${loser.eloRating}`);

    // Send game over
    const gameOverData = {
        winner: winnerId,
        loser: loserId,
        winnerUsername: winner.username,
        loserUsername: loser.username,
        winnerElo: winner.eloRating,
        loserElo: loser.eloRating,
        eloChange: winnerChange,
        reason,
        finalLives: {
            player1: game.player1Lives,
            player2: game.player2Lives
        },
        finalThrows: {
            player1: game.player1Throw,
            player2: game.player2Throw
        }
    };

    io.to(game.player1SocketId).emit('game_over', gameOverData);
    io.to(game.player2SocketId).emit('game_over', gameOverData);

    // Remove game
    games.delete(game.gameId);
}

// ============================================
// START SERVER
// ============================================

server.listen(PORT, () => {
    console.log(`\nðŸŽ² Multiplayer Mexico Backend Server`);
    console.log(`âœ… Server running on http://localhost:${PORT}`);
    console.log(`âœ… Socket.io ready for connections`);
    console.log(`\nðŸ“Š Stats: ${users.size} users, ${games.size} active games\n`);
});
